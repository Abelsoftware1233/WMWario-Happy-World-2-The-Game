<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Mario</title>
    <script src="https:/cdn.tailwindcss.com"></script>
    <style>
        @import url('https:/fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        html, body, ul, li {
            margin: 0;
            border: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            height: 100%;
        }

        body {
            background-color: #1a202c; /* Donkerdere achtergrond voor contrast */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 2rem;
            box-sizing: border-box;
        }

        .game-container {
            border: 4px solid #4a5568;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        canvas {
            display: block;
            width: 762px;
            height: 720px;
            background-color: #63b3ed;
            image-rendering: pixelated;
        }

        p {
            color: white;
            text-align: center;
            margin-top: 1rem;
        }

        .info {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.875rem;
            max-width: 200px;
        }

        .info h3 {
            font-weight: bold;
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-inter">

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="info">
        <h3 class="font-bold">Bediening</h3>
        <p>Gebruik de pijltjestoetsen om te bewegen.<br>Gebruik **X** om te springen.<br>Gebruik **Z** om te rennen.</p>
    </div>

    <script>
        / Start van de input.js logica
        (function() {
            var pressedKeys = {};

            function setKey(event, status) {
                var code = event.keyCode;
                var key;

                switch(code) {
                case 32:
                    key = 'SPACE'; break;
                case 37:
                    key = 'LEFT'; break;
                case 38:
                    key = 'UP'; break;
                case 39:
                    key = 'RIGHT'; break;
                case 40:
                    key = 'DOWN'; break;
                case 88:
                    key = 'JUMP'; break;
                case 90:
                    key = 'RUN'; break;
                default:
                    key = String.fromCharCode(code);
                }
                pressedKeys[key] = status;
            }

            document.addEventListener('keydown', function(e) {
                setKey(e, true);
            });

            document.addEventListener('keyup', function(e) {
                setKey(e, false);
            });

            window.addEventListener('blur', function() {
                pressedKeys = {};
            });

            window.input = {
                isDown: function(key) {
                    return pressedKeys[key.toUpperCase()];
                },
                reset: function() {
                    pressedKeys['RUN'] = false;
                    pressedKeys['LEFT'] = false;
                    pressedKeys['RIGHT'] = false;
                    pressedKeys['DOWN'] = false;
                    pressedKeys['JUMP'] = false;
                }
            };
        })();
        / Einde van de input.js logica

        / Start van de game.js logica met placeholders
        var requestAnimFrame = (function(){
            return window.requestAnimationFrame       ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame    ||
                window.oRequestAnimationFrame      ||
                window.msRequestAnimationFrame     ||
                function(callback){
                    window.setTimeout(callback, 1000 / 60);
                };
        })();

        / Create the canvas
        var canvas = document.getElementById("gameCanvas");
        var ctx = canvas.getContext('2d');
        var updateables = [];
        var fireballs = [];

        / --- PLAATSHOUDERS VOOR ONTBREKENDE BESTANDEN ---
        / Deze objecten zijn nodig om de game-loop te laten draaien zonder fouten.
        / U moet de echte code voor deze objecten toevoegen om het spel speelbaar te maken.

        var Mario = {
            Player: function(pos) {
                this.pos = pos;
                this.piping = false;
                this.dying = false;
                this.noInput = false;
                this.exiting = false;
                this.powering = [];
                this.invincibility = 0;
                this.run = function() { console.log("Player is running"); };
                this.noRun = function() {};
                this.jump = function() { console.log("Player is jumping"); };
                this.noJump = function() {};
                this.crouch = function() {};
                this.noCrouch = function() {};
                this.moveLeft = function() { console.log("Player is moving left"); };
                this.moveRight = function() { console.log("Player is moving right"); };
                this.noWalk = function() {};
                this.update = function(dt, vX) {};
                this.checkCollisions = function() {};
                this.render = function(ctx, vX, vY) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.pos[0] - vX, this.pos[1] - vY, 16, 16);
                };
            },
            oneone: function() { console.log("Level one-one is loaded"); }
        };

        var resources = {
            load: function(list) { console.log("Loading resources..."); },
            onReady: function(callback) { callback(); },
            get: function(path) { return { width: 16, height: 16 }; }
        };

        var level = {
            background: '#63b3ed',
            scrolling: true,
            scenery: [],
            items: [],
            enemies: [],
            pipes: [],
            statics: [],
            blocks: []
        };
        / --- EINDE PLAATSHOUDERS ---

        var player = new Mario.Player([80, 200]);

        canvas.width = 762;
        canvas.height = 720;
        ctx.scale(3,3);

        / Viewport
        var vX = 0,
            vY = 0,
            vWidth = 256,
            vHeight = 240;

        resources.load([
            'sprites/player.png',
            'sprites/enemy.png',
            'sprites/tiles.png',
            'sprites/playerl.png',
            'sprites/items.png',
            'sprites/enemyr.png',
        ]);

        resources.onReady(init);
        var sounds;
        var music;
        var lastTime;
        var gameTime = 0;

        function init() {
            music = {
                overworld: new Audio('sounds/aboveground_bgm.ogg'),
                underground: new Audio('sounds/underground_bgm.ogg'),
                clear: new Audio('sounds/stage_clear.wav'),
                death: new Audio('sounds/mariodie.wav')
            };
            sounds = {
                smallJump: new Audio('sounds/jump-small.wav'),
                bigJump: new Audio('sounds/jump-super.wav'),
                breakBlock: new Audio('sounds/breakblock.wav'),
                bump: new Audio('sounds/bump.wav'),
                coin: new Audio('sounds/coin.wav'),
                fireball: new Audio('sounds/fireball.wav'),
                flagpole: new Audio('sounds/flagpole.wav'),
                kick: new Audio('sounds/kick.wav'),
                pipe: new Audio('sounds/pipe.wav'),
                itemAppear: new Audio('sounds/itemAppear.wav'),
                powerup: new Audio('sounds/powerup.wav'),
                stomp: new Audio('sounds/stomp.wav')
            };
            Mario.oneone();
            lastTime = Date.now();
            main();
        }

        / De game-loop
        function main() {
            var now = Date.now();
            var dt = (now - lastTime) / 1000.0;
            update(dt);
            render();
            lastTime = now;
            requestAnimFrame(main);
        }

        function update(dt) {
            gameTime += dt;
            handleInput(dt);
            updateEntities(dt, gameTime);
            checkCollisions();
        }

        function handleInput(dt) {
            if (player.piping || player.dying || player.noInput) return;

            if (input.isDown('RUN')) { player.run(); } else { player.noRun(); }
            if (input.isDown('JUMP')) { player.jump(); } else { player.noJump(); }
            if (input.isDown('DOWN')) { player.crouch(); } else { player.noCrouch(); }

            if (input.isDown('LEFT')) { player.moveLeft(); }
            else if (input.isDown('RIGHT')) { player.moveRight(); }
            else { player.noWalk(); }
        }

        function updateEntities(dt, gameTime) {
            player.update(dt, vX);
            updateables.forEach(function(ent) { ent.update(dt, gameTime); });

            if (player.exiting) {
                if (player.pos[0] > vX + 96) vX = player.pos[0] - 96;
            } else if (level.scrolling && player.pos[0] > vX + 80) {
                vX = player.pos[0] - 80;
            }

            if (player.powering.length !== 0 || player.dying) { return; }
            level.items.forEach(function(ent) { ent.update(dt); });
            level.enemies.forEach(function(ent) { ent.update(dt, vX); });
            fireballs.forEach(function(fireball) { fireball.update(dt); });
            level.pipes.forEach(function(pipe) { pipe.update(dt); });
        }

        function checkCollisions() {
            if (player.powering.length !== 0 || player.dying) { return; }
            player.checkCollisions();

            level.items.forEach(function(item) { item.checkCollisions(); });
            level.enemies.forEach(function(ent) { ent.checkCollisions(); });
            fireballs.forEach(function(fireball){ fireball.checkCollisions(); });
            level.pipes.forEach(function(pipe) { pipe.checkCollisions(); });
        }

        function render() {
            updateables = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = level.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for(var i = 0; i < 15; i++) {
                for (var j = Math.floor(vX / 16) - 1; j < Math.floor(vX / 16) + 20; j++){
                    if (level.scenery[i] && level.scenery[i][j]) {
                        renderEntity(level.scenery[i][j]);
                    }
                }
            }

            level.items.forEach(function (item) { renderEntity(item); });
            level.enemies.forEach(function(enemy) { renderEntity(enemy); });
            fireballs.forEach(function(fireball) { renderEntity(fireball); });

            for(var i = 0; i < 15; i++) {
                for (var j = Math.floor(vX / 16) - 1; j < Math.floor(vX / 16) + 20; j++){
                    if (level.statics[i] && level.statics[i][j]) { renderEntity(level.statics[i][j]); }
                    if (level.blocks[i] && level.blocks[i][j]) {
                        renderEntity(level.blocks[i][j]);
                        updateables.push(level.blocks[i][j]);
                    }
                }
            }

            if (player.invincibility % 2 === 0) { renderEntity(player); }

            level.pipes.forEach(function(pipe) { renderEntity(pipe); });
        }

        function renderEntity(entity) {
            entity.render(ctx, vX, vY);
        }
    </script>
</body>
</html>
